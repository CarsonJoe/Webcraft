
================================================================================
File: ./scripts/constants.js
================================================================================

// constants.js
export const CHUNK_SIZE = 18; 
export const CHUNK_HEIGHT = 120;
export const WATER_LEVEL = 24;
export const BEACH_LEVEL = WATER_LEVEL + 2;
export const RENDER_DISTANCE = 15;

================================================================================
File: ./scripts/main.js
================================================================================

import Player from './player.js';
import { CHUNK_HEIGHT } from './constants.js';
import { updateChunks, setBlock, getBlock, waterMaterial } from './world.js';
import { initWorld, notifySceneReady, initializationComplete } from './world.js';
import { createSkybox, initRenderer, render, chunkMeshes } from './renderer.js';

// Set up the scene, camera, and renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = initRenderer(scene, camera);
initWorld();
notifySceneReady();

// Create and apply the skybox
createSkybox(scene, renderer);



// Add ambient light
const ambientLight = new THREE.AmbientLight(0x404050);
scene.add(ambientLight);

// Add directional light
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

// Cloud setup
import SimplexNoise from 'https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/+esm';
import { profiler } from './profiler.js';

// Generate tileable noise texture using toroidal mapping
const CLOUD_TEX_SIZE = 512;
const simplex = new SimplexNoise();

// Toroidal noise parameters
const NOISE_SCALE = 1.0;
const TORUS_MAJOR_RADIUS = 2.0;
const TORUS_MINOR_RADIUS = 1.0;

const noiseData = new Uint8Array(CLOUD_TEX_SIZE * CLOUD_TEX_SIZE * 4);

for (let x = 0; x < CLOUD_TEX_SIZE; x++) {
    for (let y = 0; y < CLOUD_TEX_SIZE; y++) {
        // Create toroidal coordinates for seamless wrapping
        const theta = (x / CLOUD_TEX_SIZE) * Math.PI * 2;
        const phi = (y / CLOUD_TEX_SIZE) * Math.PI * 2;

        // Convert to 3D torus coordinates
        const tx = (TORUS_MAJOR_RADIUS + TORUS_MINOR_RADIUS * Math.cos(theta)) * Math.cos(phi) * NOISE_SCALE;
        const ty = (TORUS_MAJOR_RADIUS + TORUS_MINOR_RADIUS * Math.cos(theta)) * Math.sin(phi) * NOISE_SCALE;
        const tz = TORUS_MINOR_RADIUS * Math.sin(theta) * NOISE_SCALE;

        // Get 3D noise value
        const value = simplex.noise3D(tx, ty, tz);

        // Convert to 0-255 range
        const normalized = (value + 1) * 127.5;
        const idx = (y * CLOUD_TEX_SIZE + x) * 4;
        noiseData[idx] = normalized;
        noiseData[idx + 1] = normalized;
        noiseData[idx + 2] = normalized;
        noiseData[idx + 3] = 255;
    }
}

const cloudTexture = new THREE.DataTexture(
    noiseData,
    CLOUD_TEX_SIZE,
    CLOUD_TEX_SIZE,
    THREE.RGBAFormat
);
cloudTexture.wrapS = THREE.RepeatWrapping;
cloudTexture.wrapT = THREE.RepeatWrapping;
cloudTexture.minFilter = THREE.LinearFilter;
cloudTexture.magFilter = THREE.LinearFilter;
cloudTexture.needsUpdate = true;
// Cloud material
const cloudMaterial = new THREE.ShaderMaterial({
    uniforms: {
        time: { value: 0 },
        dayNightCycle: { value: 0.5 },
        cloudTexture: { value: cloudTexture },
        lightDirection: { value: directionalLight.position.normalize() },
        cloudSpeed: { value: 0.0005 },  // Increased default speed
        cloudCover: { value: 0.9 },  // Added cloud cover parameter
        densityScale: { value: .9 }, // Adjusted default density
        lightIntensity: { value: .5 },
        cloudPosition: { value: new THREE.Vector3() }
    },
    vertexShader: `
    varying vec2 vUv;
    varying vec3 vWorldPosition;
    void main() {
      vUv = uv;
      vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform sampler2D cloudTexture;
    uniform float time;
    uniform float dayNightCycle;
    uniform vec3 lightDirection;
    uniform float cloudSpeed;
    uniform float cloudCover;
    uniform float densityScale;
    varying vec2 vUv;
    varying vec3 vWorldPosition;
    uniform vec3 cloudPosition;

    #define OCTAVES 4

    float fbm(vec2 uv) {
        float value = 0.0;
        float amplitude = 0.5;
        float frequency = 1.0;
        
        for(int i = 0; i < OCTAVES; i++) {
            vec2 sampleUV = uv * frequency + time * cloudSpeed;
            float noise = texture2D(cloudTexture, sampleUV).r;
            value += amplitude * noise;
            amplitude *= 0.5;
            frequency *= 2.0;
        }
        
        return value;
    }

    float getCloudDensity(vec2 uv) {
        // Frequency-based speed scaling
        float speed1 = cloudSpeed / 0.8; // Compensate for uv * 0.8
        float speed2 = cloudSpeed / 2.5; // Compensate for uv * 2.5
        float speed3 = cloudSpeed / 0.3; // Compensate for uv * 0.3

        vec2 uv1 = uv * 0.8 + vec2(time * speed1, 0.0);
        vec2 uv2 = uv * 2.5 + vec2(0.0, time * speed2 * 0.7); // Reduced vertical speed
        vec2 uv3 = uv * 0.3 - vec2(time * speed3 * 0.3); // Slower diagonal movement
        
        // Cloud layers
        float baseClouds = fbm(uv1);
        float details = fbm(uv2) * 0.3;
        float largeScale = smoothstep(0.3, 0.8, fbm(uv3)) * 0.5;
        
        // Combine layers and apply density scale
        float density = (baseClouds * largeScale + details) * densityScale;
        
        // Cloud cover control
        float coverageThreshold = mix(0.3, -0.2, cloudCover);
        density = smoothstep(coverageThreshold, coverageThreshold + 0.5, density);
        
        return clamp(density, 0.0, 1.0);
    }

    void main() {
        vec2 uv = vUv * 2.0;
        float density = getCloudDensity(uv);
        
        // Lighting calculations
        vec3 normal = vec3(0.0, 1.0, 0.0);
        float lightIntensity = dot(normal, lightDirection) * 0.5 + 0.5;
        
        // Color variations
        vec3 baseColor = mix(vec3(0.4, 0.45, 0.5), vec3(1.0, 0.98, 0.95), density);
        vec3 shadedColor = mix(baseColor * 0.7, baseColor * 1.2, lightIntensity);
        vec3 ambientColor = mix(vec3(0.25, 0.3, 0.4), vec3(0.5, 0.6, 0.8), dayNightCycle);
        
        // Final color and opacity
        vec3 finalColor = mix(ambientColor, shadedColor, density * 0.8);
        float alpha = smoothstep(0.1, 0.9, density) * 0.8;
        alpha *= mix(0.8, 1.2, fbm(uv * 5.0 + time * 0.1));
        
        // Calculate edge fade
        vec2 localPos = vWorldPosition.xz - cloudPosition.xz;
        float distanceFromCenter = length(localPos) / 1500.0;
        float edgeFade = 1.0 - smoothstep(0.1, 1.0, distanceFromCenter);
        alpha *= edgeFade;

        gl_FragColor = vec4(finalColor, alpha * 0.85);
    }
  `,
    transparent: true,
    depthWrite: false,
    side: THREE.DoubleSide
});

// Cloud plane
const cloudGeometry = new THREE.PlaneGeometry(3000, 3000); // Increased size
cloudGeometry.rotateX(-Math.PI / 2);
const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
clouds.position.y = 180;
clouds.renderOrder = -1; // Render before other objects
scene.add(clouds);

function updateCloudPosition() {
    const playerPos = Player.getPosition();
    clouds.position.x = playerPos.x;
    clouds.position.z = playerPos.z;
}

// Initialize the player
Player.init(camera, scene);


// Prevent default right-click behavior
document.addEventListener('contextmenu', (event) => event.preventDefault());

// Animation loop
let gameStarted = false;

function animate() {
    requestAnimationFrame(animate);
    profiler.startFrame();

    if (!gameStarted) {
        if (initializationComplete) {
            gameStarted = true;
        }
        return;
    }

    if (cloudMaterial) {
        cloudMaterial.uniforms.time.value = performance.now() / 1000;
        cloudMaterial.uniforms.cloudPosition.value.copy(clouds.position);
    }

    // Update water material uniforms
    if (waterMaterial && waterMaterial.uniforms && waterMaterial.uniforms.time) {
        waterMaterial.uniforms.time.value = performance.now() / 1000;
        waterMaterial.uniforms.lightDirection.value.copy(directionalLight.position).normalize();
        waterMaterial.uniforms.fogColor.value.copy(scene.fog.color);
        waterMaterial.uniforms.fogNear.value = scene.fog.near;
        waterMaterial.uniforms.fogFar.value = scene.fog.far;
        const cameraWorldPos = new THREE.Vector3();
        camera.getWorldPosition(cameraWorldPos);

        waterMaterial.uniforms.cameraPos.value.copy(cameraWorldPos);
    }

    Player.update(getBlock);
    updateChunks(Player.getPosition());
    updateCloudPosition();

    // Update camera matrix for frustum culling
    camera.updateMatrixWorld();

    // Force render even if no changes
    render(scene, camera);
    
    profiler.endFrame();
    updateDebugUI();
}

animate();

function updateDebugUI() {
    const metrics = profiler.getMetrics();
    const frameStats = [
        `Frame: ${metrics.frame.current}ms`,
        `Avg: ${metrics.frame.avg}ms`,
        `Min: ${metrics.frame.min}ms`,
        `Max: ${metrics.frame.max}ms`
    ];

    const chunkStats = [
        `Generated: ${metrics.chunks.generated}`,
        `Meshed: ${metrics.chunks.meshed}`,
        `Loaded: ${Object.keys(chunkMeshes).length}`
    ];

    const memoryStats = [
        `Geometry: ${metrics.memory.geometry}MB`,
        `Total: ${metrics.memory.total}MB`
    ];

    document.getElementById('frame-stats').innerHTML = frameStats.join('<br>');
    document.getElementById('chunk-stats').innerHTML = chunkStats.join('<br>');
    document.getElementById('memory-stats').innerHTML = memoryStats.join('<br>');
}


// Handle window resizing
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}, false);


// Make necessary functions and variables available globally
window.setBlock = setBlock;
window.getBlock = getBlock;
window.CHUNK_HEIGHT = CHUNK_HEIGHT;

================================================================================
File: ./scripts/world.js
================================================================================

import { CHUNK_SIZE, CHUNK_HEIGHT, WATER_LEVEL, RENDER_DISTANCE } from './constants.js';
import { chunkMeshes, removeChunkGeometry, scene } from './renderer.js';

// Chunk states and initialization flags
const CHUNK_LOADING = 1;
const CHUNK_LOADED = 2;
let chunkWorker = null;
export let geometryWorkers = [];
let currentGeometryWorkerIndex = 0;
let initializationComplete = false;
let workerInitialized = false;
let sceneReady = false;
export let spawnPoint = null;
export const collisionGeometry = new Map();


let lastUpdateTime = 0;
const UPDATE_COOLDOWN = 100; // ms

// Chunk storage and queues
const chunks = {};
const chunkStates = {};
const queuedChunks = new Set(); // Track chunk keys like "x,z"
let remeshQueue = new Set();
const chunkLoadQueue = [];      // Use as a priority queue (heap)
const blockColors = new Map();

let currentPlayerChunkX = 0;
let currentPlayerChunkZ = 0;

// Performance management
const MAX_CHUNKS_PER_FRAME = 50;
let frameBudget = 16; // Start with 16ms (~60fps)
let lastFrameTime = performance.now();

// Materials definition
const materials = {
    0: { color: 0x000000 }, // Air
    1: { color: 0x6cc66c }, // Grass
    2: { color: 0x997260 }, // Dirt
    3: { color: 0x888888 }, // Stone
    4: { color: 0xe3dda6 }, // Sand
    5: { color: 0x6380ec }, // Water
    6: { color: 0x7b6e65 }, // Wood
    7: { color: 0x1f541f }, // Leaves
    8: { color: 0x3b4044 }, // Slate
    9: { color: 0xFFFFFF }  // Limestone
};

const solidMaterial = new THREE.MeshLambertMaterial({ vertexColors: true });
export const waterMaterial = new THREE.ShaderMaterial({
    uniforms: {
        time: { value: 0 },
        waterColor: { value: new THREE.Color(0x6fbffc) },
        lightDirection: { value: new THREE.Vector3(1, 1, 1).normalize() },
        waveScale: { value: .2 },
        fogColor: { value: new THREE.Color(0x619dde) },
        fogNear: { value: 20 },
        fogFar: { value: 300 },
        cameraPos: { value: new THREE.Vector3() }, // Added camera position
        reflectionIntensity: { value: 0.2 } // New uniform for reflection control
    },
    vertexShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying float vDisplacement;
        uniform float time;
        uniform float waveScale;

        // Classic Perlin noise implementation
        vec4 permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        
        float noise(vec3 P) {
            vec3 Pi0 = floor(P); // Integer part for indexing
            vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
            vec3 Pf0 = fract(P); // Fractional part for interpolation
            vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
            vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
            vec4 iy = vec4(Pi0.yy, Pi1.yy);
            vec4 iz0 = Pi0.zzzz;
            vec4 iz1 = Pi1.zzzz;

            vec4 ixy = permute(permute(ix) + iy);
            vec4 ixy0 = permute(ixy + iz0);
            vec4 ixy1 = permute(ixy + iz1);

            vec4 gx0 = ixy0 / 7.0;
            vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
            gx0 = fract(gx0);
            vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
            vec4 sz0 = step(gz0, vec4(0.0));
            gx0 -= sz0 * (step(0.0, gx0) - 0.5);
            gy0 -= sz0 * (step(0.0, gy0) - 0.5);

            vec4 gx1 = ixy1 / 7.0;
            vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
            gx1 = fract(gx1);
            vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
            vec4 sz1 = step(gz1, vec4(0.0));
            gx1 -= sz1 * (step(0.0, gx1) - 0.5);
            gy1 -= sz1 * (step(0.0, gy1) - 0.5);

            vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
            vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
            vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
            vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
            vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
            vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
            vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
            vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

            vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
            g000 *= norm0.x;
            g010 *= norm0.y;
            g100 *= norm0.z;
            g110 *= norm0.w;

            vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
            g001 *= norm1.x;
            g011 *= norm1.y;
            g101 *= norm1.z;
            g111 *= norm1.w;

            float n000 = dot(g000, Pf0);
            float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
            float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
            float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
            float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
            float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
            float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
            float n111 = dot(g111, Pf1);

            vec3 fade_xyz = Pf0 * Pf0 * Pf0 * (Pf0 * (Pf0 * 6.0 - 15.0) + 10.0);
            vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
            vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
            float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
            return 2.2 * n_xyz;
        }

        void main() {
            vec4 baseWorldPosition = modelMatrix * vec4(position, 1.0);
            float worldX = baseWorldPosition.x;
            float worldZ = baseWorldPosition.z;
            
            // Large waves (unchanged)
            float displacement = noise(vec3(worldX * 0.3, worldZ * 0.3, time * 0.1)) * waveScale;
            displacement += sin(worldX * 0.5 + time) * 0.2 * waveScale;
            
            // Smaller wave ripples
            float rippleFrequency = 10.0; // Higher frequency for tighter ripples in x and z
            float rippleAmplitude = 0.2; // Larger amplitude for taller ripples in y
            displacement += noise(vec3(worldX * rippleFrequency, worldZ * rippleFrequency, time * 1.0)) * rippleAmplitude;
            displacement += sin(worldX * rippleFrequency + time * .1) * 0.1 * rippleAmplitude;
            
            displacement = clamp(displacement, -0.5, 0.5);
            
            vDisplacement = displacement; // Pass displacement to fragment shader
            
            vec3 pos = position;
            pos.y += displacement;
            vec4 displacedWorldPosition = modelMatrix * vec4(pos, 1.0);
            vWorldPosition = displacedWorldPosition.xyz;

            // Simplified normal calculation (unchanged)
            float eps = 0.1;
            float dx = noise(vec3((worldX + eps) * 0.3, worldZ * 0.3, time * 0.5)) - 
                    noise(vec3((worldX - eps) * 0.3, worldZ * 0.3, time * 0.5));
            float dz = noise(vec3(worldX * 0.3, (worldZ + eps) * 0.3, time * 0.5)) - 
                    noise(vec3(worldX * 0.3, (worldZ - eps) * 0.3, time * 0.5));
            
            vNormal = normalize(vec3(-dx * 2.0, 1.0, -dz * 2.0));
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    `,
    fragmentShader: `
    varying vec3 vNormal;
    varying vec3 vWorldPosition;
    varying float vDisplacement;
    uniform vec3 waterColor;
    uniform vec3 lightDirection;
    uniform vec3 fogColor;
    uniform float fogNear;
    uniform float fogFar;
    uniform vec3 cameraPos; // Camera position uniform
    uniform float reflectionIntensity;

    void main() {
        vec3 normal = normalize(vNormal);
        vec3 lightDir = normalize(lightDirection);
        vec3 viewDir = normalize(cameraPos - vWorldPosition); // Calculate view direction

        // Fresnel effect calculation
        float fresnel = pow(clamp(1.0 - dot(normal, viewDir), 0.0, 1.0), 5.0);
        fresnel *= reflectionIntensity; // Control reflection strength

        // Base color gradient from displacement
        float gradientFactor = smoothstep(-0.9, 0.9, vDisplacement);
        vec3 darkColor = waterColor * 0.95;
        vec3 lightColor = waterColor * 1.05;
        vec3 baseColor = mix(darkColor, lightColor, gradientFactor);

        // Specular highlights (Blinn-Phong model)
        vec3 halfDir = normalize(lightDir + viewDir);
        float specular = pow(max(dot(normal, halfDir), 0.0), 128.0);
        vec3 specularColor = vec3(1.0) * specular * fresnel;

        // Combine colors with Fresnel effect
        vec3 reflectionColor = mix(baseColor, vec3(1.0), fresnel);
        vec3 finalColor = mix(baseColor, reflectionColor, fresnel) * 
                        max(dot(normal, lightDir), 0.2) + 
                        specularColor;

        // Apply fog
        float depth = distance(vWorldPosition, cameraPos);
        float fogFactor = smoothstep(fogNear, fogFar, depth);
        finalColor = mix(finalColor, fogColor, fogFactor);

        // Alpha based on displacement
        float alpha = 0.8 + 0.2 * abs(vDisplacement);

        gl_FragColor = vec4(finalColor, alpha);
    }
`,
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false
});


let leavesMaterial = null;

// Initialize world systems
export function initWorld() {
    console.log("[World] Initializing world system...");
    const SEED = Math.random() * 1000000;
    console.log(`[World] Using seed: ${SEED}`);


    addToLoadQueue(0, 0, 0);

    // Generate initial spawn point at chunk (0,0)
    spawnPoint = findSuitableSpawnPoint(0, 0);
    console.log("Generated spawn point:", spawnPoint);

    const workerCount = navigator.hardwareConcurrency || 4;
    geometryWorkers = [];

    for (let i = 0; i < workerCount; i++) {
        const worker = new Worker(new URL('./geometryWorker.js', import.meta.url), { type: 'module' });
        worker.postMessage({
            type: 'init',
            materials: materials,
            seed: SEED
        });

        worker.onmessage = function (e) {
            if (e.data.type === 'geometry_data') {
                try {
                    if (e.data.solid.positions.length > 0 || e.data.water.positions.length > 0 || e.data.leaves.positions.length > 0) {
                        createChunkMeshes(e.data.chunkX, e.data.chunkZ, e.data.solid, e.data.water, e.data.leaves);
                    }
                } catch (error) {
                    console.error('Error processing geometry:', error);
                }
            }
        };
        geometryWorkers.push(worker);
    }

    chunkWorker = new Worker(new URL('./chunksWorker.js', import.meta.url), {
        type: 'module'
    });
    console.log("[World] Web Worker created");

    chunkWorker.onmessage = function (e) {
        if (e.data.type === 'init_complete') {
            workerInitialized = true;
            checkInitialization();
            if (sceneReady) {
                processChunkQueue();
            }
        } else if (e.data.type === 'chunk_data') {
            const { chunkX, chunkZ, chunkData } = e.data;
            const chunkKey = `${chunkX},${chunkZ}`;

            // 1. Clone the received buffer for main thread storage
            const clonedBuffer = new ArrayBuffer(chunkData.byteLength);
            new Int8Array(clonedBuffer).set(new Int8Array(chunkData));

            // 2. Store cloned buffer in chunks
            chunks[chunkKey] = new Int8Array(clonedBuffer);
            chunkStates[chunkKey] = CHUNK_LOADED;

            // 3. Prepare adjacent chunks with fresh buffers
            const transferList = [chunkData]; // Transfer original buffer
            const adjacentChunks = {};

            [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dz]) => {
                const adjKey = `${chunkX + dx},${chunkZ + dz}`;
                if (chunks[adjKey]) {
                    // Clone adjacent chunk's buffer for transfer
                    const adjClone = new ArrayBuffer(chunks[adjKey].buffer.byteLength);
                    new Int8Array(adjClone).set(chunks[adjKey]);
                    adjacentChunks[adjKey] = adjClone;
                    transferList.push(adjClone);
                }
            });

            // 4. Send message with transferrable buffers
            const worker = geometryWorkers[currentGeometryWorkerIndex];
            currentGeometryWorkerIndex = (currentGeometryWorkerIndex + 1) % geometryWorkers.length;

            worker.postMessage({
                type: 'process_chunk',
                chunkX,
                chunkZ,
                chunkData: chunkData,
                adjacentChunks,
                isInitialGeneration: true
            }, transferList);

            updateAdjacentChunks(chunkX, chunkZ);
        }
    };

    console.log("[World] Sending worker init message");
    chunkWorker.postMessage({
        type: 'init',
        seed: SEED
    });
}

function createChunkMeshes(chunkX, chunkZ, solidData, waterData, leavesData) {
    const chunkKey = `${chunkX},${chunkZ}`;

    // Initialize leaves material once
    if (!leavesMaterial) {
        leavesMaterial = new THREE.ShaderMaterial({
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.fog, // Includes fogColor, fogNear, fogFar
                {
                    // Add any custom uniforms here if needed
                }
            ]),
            vertexShader: `
                varying vec3 vColor;
                varying float vFogDepth;
                attribute vec2 offset;

                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    
                    // Billboard calculations
                    vec3 look = normalize(worldPosition.xyz - cameraPosition);
                    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), look));
                    vec3 up = cross(look, right);
                    
                    // Apply 1.7x scale
                    vec3 pos = worldPosition.xyz;
                    pos += right * offset.x * 1.36; // 0.8 * 1.7
                    pos += up * offset.y * 1.36;
                    
                    // Transform to view space
                    vec4 mvPosition = viewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Depth adjustments
                    gl_Position.z -= 0.0003; // Depth bias
                    vFogDepth = -mvPosition.z; // For fog calculation
                    
                    vColor = color;
                }
            `,
            fragmentShader: `
                uniform vec3 fogColor;
                uniform float fogNear;
                uniform float fogFar;
                
                varying vec3 vColor;
                varying float vFogDepth;
                
                void main() {
                    // Base color
                    vec3 color = vColor;
                    
                    // Fog calculation
                    float fogFactor = smoothstep(fogNear, fogFar, vFogDepth);
                    
                    // Apply fog
                    color = mix(color, fogColor, fogFactor);
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            transparent: false,
            depthWrite: true,
            depthTest: true,
            alphaTest: 0.5,
            fog: true,
            vertexColors: true,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: 1.0,
            polygonOffsetUnits: 1.0,
        });
    }

    // Remove existing meshes safely
    if (chunkMeshes[chunkKey]) {
        const { solid, water, leaves } = chunkMeshes[chunkKey];
        
        // Always remove from scene if they exist
        if (solid) {
            scene.remove(solid);
            if (solid.geometry) solid.geometry.dispose();
        }
        if (water) {
            scene.remove(water);
            if (water.geometry) water.geometry.dispose();
        }
        if (leaves) {
            scene.remove(leaves);
            if (leaves.geometry) leaves.geometry.dispose();
        }
    }

    // Create new meshes only if they have geometry
    let solidMesh = null;
    let waterMesh = null;
    let leavesMesh = null;

    // Create solid mesh if data exists
    if (solidData?.positions?.length > 0) {
        const solidGeometry = createGeometryFromData(solidData);
        solidMesh = new THREE.Mesh(solidGeometry, solidMaterial);
    }

    // Create water mesh if data exists
    if (waterData?.positions?.length > 0) {
        const waterGeometry = createGeometryFromData(waterData);
        waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
    }

    // Create leaves mesh if data exists
    if (leavesData?.positions?.length > 0) {
        const leavesGeometry = new THREE.BufferGeometry();
        leavesGeometry.setAttribute('position', new THREE.BufferAttribute(leavesData.positions, 3));
        leavesGeometry.setAttribute('offset', new THREE.BufferAttribute(leavesData.offsets, 2));
        leavesGeometry.setAttribute('color', new THREE.BufferAttribute(leavesData.colors, 3));
        leavesGeometry.setIndex(new THREE.BufferAttribute(leavesData.indices, 1));
        leavesMesh = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leavesMesh.frustumCulled = false;
        leavesMesh.renderOrder = 1;
    }

    // Position and add meshes to scene
    const worldX = chunkX * CHUNK_SIZE;
    const worldZ = chunkZ * CHUNK_SIZE;

    if (solidMesh) {
        solidMesh.position.set(worldX, 0, worldZ);
        scene.add(solidMesh);
        solidMesh.castShadow = true;
        solidMesh.receiveShadow = true;
    }

    if (waterMesh) {
        waterMesh.position.set(worldX, 0, worldZ);
        scene.add(waterMesh);
        waterMesh.receiveShadow = true;
    }

    if (leavesMesh) {
        leavesMesh.position.set(worldX, 0, worldZ);
        scene.add(leavesMesh);
    }

    // Update chunk meshes reference
    chunkMeshes[chunkKey] = { 
        solid: solidMesh || null, 
        water: waterMesh || null, 
        leaves: leavesMesh || null 
    };
}

function createGeometryFromData(data) {
    const geometry = new THREE.BufferGeometry();

    geometry.setAttribute('position', new THREE.BufferAttribute(data.positions, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(data.normals, 3));

    if (data.colors) {
        geometry.setAttribute('color', new THREE.BufferAttribute(data.colors, 3));
    }

    geometry.setIndex(new THREE.BufferAttribute(data.indices, 1));
    geometry.computeBoundingSphere();

    return geometry;
}

// Notify when scene is ready
export function notifySceneReady() {
    sceneReady = true;
    console.log("[World] Scene ready:", sceneReady);
    checkInitialization();
}

function checkInitialization() {
    if (workerInitialized && sceneReady) {
        initializationComplete = true;
        console.log("[World] Full initialization complete");
        // Start initial chunk processing
        processChunkQueue();
    }
}

function updateAdjacentChunks(chunkX, chunkZ) {
    const neighbors = [
        [chunkX + 1, chunkZ],
        [chunkX - 1, chunkZ],
        [chunkX, chunkZ + 1],
        [chunkX, chunkZ - 1]
    ];

    neighbors.forEach(([x, z]) => {
        const key = `${x},${z}`;
        if (chunks[key] && chunkStates[key] === CHUNK_LOADED) {
            // Send existing adjacent chunks to geometry worker for mesh regeneration
            sendChunkToGeometryWorker(x, z);
        }
    });
}

const PRIORITY_BANDS = [
    {distance: 2, chunksPerFrame: 5},    // Immediate area
    {distance: 4, chunksPerFrame: 3},    // Near area
    {distance: RENDER_DISTANCE * 2, chunksPerFrame: 2} // Far area
];

function addToLoadQueue(x, z) {
    const chunkKey = `${x},${z}`;
    const dx = Math.abs(x - currentPlayerChunkX);
    const dz = Math.abs(z - currentPlayerChunkZ);
    const distance = dx + dz; // Manhattan distance

    // Skip if out of bounds or already queued
    if (distance > RENDER_DISTANCE * 2 + 1 || queuedChunks.has(chunkKey)) return;

    // Assign priority band
    let priority = PRIORITY_BANDS.findIndex(b => distance <= b.distance);
    priority = priority === -1 ? PRIORITY_BANDS.length : priority;

    // Store in simple array with priority
    chunkLoadQueue.push({x, z, priority});
    queuedChunks.add(chunkKey);
}

function processChunkQueue() {
    if (!workerInitialized || !sceneReady) return;

    const now = performance.now();
    const timeSinceLastFrame = now - lastFrameTime;
    lastFrameTime = now;

    if (timeSinceLastFrame < 16) {
        frameBudget += 16 - timeSinceLastFrame;
    } else {
        frameBudget -= timeSinceLastFrame - 16;
    }

    frameBudget = Math.max(8, Math.min(32, frameBudget));

    const startTime = performance.now();
    let processed = 0;

    // Process load queue first
    while (chunkLoadQueue.length > 0 && processed < MAX_CHUNKS_PER_FRAME) {
        const { x, z } = chunkLoadQueue.shift();
        queuedChunks.delete(`${x},${z}`);
        const chunkKey = `${x},${z}`;

        if (!chunks[chunkKey] && chunkStates[chunkKey] !== CHUNK_LOADING) {
            chunkStates[chunkKey] = CHUNK_LOADING;
            chunkWorker.postMessage({ chunkX: x, chunkZ: z });
            processed++;
        }

        if (performance.now() - startTime > frameBudget) break;
    }

    // Process remesh queue
    remeshQueue.forEach(chunkKey => {
        const [x, z] = chunkKey.split(',').map(Number);
        if (!chunks[chunkKey]) {
            remeshQueue.delete(chunkKey);
            return;
        }
    
        // Add adjacency check to prevent unnecessary remeshing
        const isEdgeChunk = 
            x === currentPlayerChunkX - RENDER_DISTANCE ||
            x === currentPlayerChunkX + RENDER_DISTANCE ||
            z === currentPlayerChunkZ - RENDER_DISTANCE ||
            z === currentPlayerChunkZ + RENDER_DISTANCE;
    
        if (!isEdgeChunk) {
            // Check if all neighbors are loaded
            const neighborsLoaded = [[1, 0], [-1, 0], [0, 1], [0, -1]].every(([dx, dz]) => {
                const neighborKey = `${x + dx},${z + dz}`;
                return chunks[neighborKey] && chunkStates[neighborKey] === CHUNK_LOADED;
            });
    
            if (!neighborsLoaded) return;
        }
    
        const chunkData = chunks[chunkKey];
        const clonedChunkData = new Int8Array(chunkData).buffer;
    
        const adjacentChunks = {};
        [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dz]) => {
            const adjChunkX = x + dx;
            const adjChunkZ = z + dz;
            const adjKey = `${adjChunkX},${adjChunkZ}`;
            if (chunks[adjKey]) {
                const adjClone = new Int8Array(chunks[adjKey]).buffer;
                adjacentChunks[adjKey] = adjClone;
            }
        });
    
        const transferList = [clonedChunkData];
        Object.values(adjacentChunks).forEach(buffer => transferList.push(buffer));
    
        // Select the next worker in the pool
        const worker = geometryWorkers[currentGeometryWorkerIndex];
        currentGeometryWorkerIndex = (currentGeometryWorkerIndex + 1) % geometryWorkers.length;
    
        // Send the chunk data to the selected worker
        worker.postMessage({
            type: 'process_chunk',
            chunkX: x,
            chunkZ: z,
            chunkData: clonedChunkData,
            adjacentChunks,
            isInitialGeneration: false
        }, transferList);
    
        // Remove the chunk from the remesh queue
        remeshQueue.delete(chunkKey);
    });
    remeshQueue.clear();

    if (chunkLoadQueue.length > 0 || remeshQueue.size > 0) {
        requestAnimationFrame(processChunkQueue);
    }
}

function getBlock(x, y, z) {
    const chunkX = Math.floor(x / CHUNK_SIZE);
    const chunkZ = Math.floor(z / CHUNK_SIZE);
    const chunkKey = `${chunkX},${chunkZ}`;

    if (!chunks[chunkKey]) {
        if (chunkStates[chunkKey] !== CHUNK_LOADING) {
            addToLoadQueue(chunkX, chunkZ, Infinity);
        }
        return 0;
    }

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (y < 0 || y >= CHUNK_HEIGHT) return 0;

    return chunks[chunkKey][localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] || 0;
}

function setBlock(x, y, z, type) {
    const chunkX = Math.floor(x / CHUNK_SIZE);
    const chunkZ = Math.floor(z / CHUNK_SIZE);
    const chunkKey = `${chunkX},${chunkZ}`;

    if (!chunks[chunkKey]) {
        if (chunkStates[chunkKey] !== CHUNK_LOADING) {
            addToLoadQueue(chunkX, chunkZ, Infinity);
        }
        return;
    }

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (y < 0 || y >= CHUNK_HEIGHT) return;

    chunks[chunkKey][localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = type;
    addToLoadQueue(chunkX, chunkZ, 0);
}

function updateBlock(x, y, z, newBlockType) {
    if (performance.now() - lastUpdateTime < UPDATE_COOLDOWN) return;
    lastUpdateTime = performance.now();
    const chunkX = Math.floor(x / CHUNK_SIZE);
    const chunkZ = Math.floor(z / CHUNK_SIZE);
    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    const chunkKey = `${chunkX},${chunkZ}`;
    if (!chunks[chunkKey]) return;

    const index = localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE;
    chunks[chunkKey][index] = newBlockType;

    addToLoadQueue(chunkX, chunkZ, 0);
    sendChunkToGeometryWorker(chunkX, chunkZ);

    if (localX === 0) sendChunkToGeometryWorker(chunkX - 1, chunkZ);
    if (localX === CHUNK_SIZE - 1) sendChunkToGeometryWorker(chunkX + 1, chunkZ);
    if (localZ === 0) sendChunkToGeometryWorker(chunkX, chunkZ - 1);
    if (localZ === CHUNK_SIZE - 1) sendChunkToGeometryWorker(chunkX, chunkZ + 1);
}

function sendChunkToGeometryWorker(chunkX, chunkZ) {
    const chunkKey = `${chunkX},${chunkZ}`;
    remeshQueue.add(chunkKey);
}

function updateChunks(playerPosition) {
    if (!playerPosition || !initializationComplete) return;

    // Update player chunk position
    currentPlayerChunkX = Math.floor(playerPosition.x / CHUNK_SIZE);
    currentPlayerChunkZ = Math.floor(playerPosition.z / CHUNK_SIZE);

    const chunksToKeep = new Set();
    const buffer = RENDER_DISTANCE + 1;

    // First pass: Collect all chunks in rectangular area
    const chunksToCheck = [];
    for (let dx = -buffer; dx <= buffer; dx++) {
        for (let dz = -buffer; dz <= buffer; dz++) {
            const x = currentPlayerChunkX + dx;
            const z = currentPlayerChunkZ + dz;
            chunksToCheck.push({ x, z });
            chunksToKeep.add(`${x},${z}`);
        }
    }

    // Sort chunks by distance to player
    chunksToCheck.sort((a, b) => {
        const aDx = a.x - currentPlayerChunkX;
        const aDz = a.z - currentPlayerChunkZ;
        const bDx = b.x - currentPlayerChunkX;
        const bDz = b.z - currentPlayerChunkZ;
        return (aDx * aDx + aDz * aDz) - (bDx * bDx + bDz * bDz);
    });

    // Add chunks to queue in sorted order
    chunksToCheck.forEach(({ x, z }) => addToLoadQueue(x, z));

    // Remove out-of-range chunks
    Object.keys(chunkMeshes).forEach(chunkKey => {
        if (!chunksToKeep.has(chunkKey)) {
            const [x, z] = chunkKey.split(',').map(Number);
            const dx = x - currentPlayerChunkX;
            const dz = z - currentPlayerChunkZ;

            if (Math.abs(dx) > buffer || Math.abs(dz) > buffer) {
                removeChunkGeometry(x, z);
                cleanupChunkData(chunkKey);
            }
        }
    });

    processChunkQueue();
}

// New cleanup function in world.js
function cleanupChunkData(chunkKey) {
    // Clear chunk data
    delete chunks[chunkKey];
    delete chunkStates[chunkKey];
}

function findSuitableSpawnPoint(chunkX, chunkZ) {
    const chunkKey = `${chunkX},${chunkZ}`;
    if (!chunks[chunkKey]) {
        // Changed from Infinity to 0 for highest priority
        addToLoadQueue(chunkX, chunkZ, 0);
        return {
            x: chunkX * CHUNK_SIZE + CHUNK_SIZE / 2,
            y: CHUNK_HEIGHT, // Start at top
            z: chunkZ * CHUNK_SIZE + CHUNK_SIZE / 2
        };
    }

    const centerX = Math.floor(CHUNK_SIZE / 2);
    const centerZ = Math.floor(CHUNK_SIZE / 2);
    let spawnY = 0;

    for (let y = CHUNK_HEIGHT - 1; y >= 0; y--) {
        if (chunks[chunkKey][centerX + centerZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] !== 0) {
            spawnY = y + 2;
            break;
        }
    }

    if (spawnY <= WATER_LEVEL) {
        spawnY = WATER_LEVEL + 2;
    }

    return {
        x: chunkX * CHUNK_SIZE + centerX,
        y: spawnY,
        z: chunkZ * CHUNK_SIZE + centerZ
    };
}

export {
    updateChunks,
    setBlock,
    getBlock,
    chunks,
    materials,
    blockColors,
    updateBlock,
    findSuitableSpawnPoint,
    addToLoadQueue,
    initializationComplete,
};


================================================================================
File: ./scripts/chunksWorker.js
================================================================================

import SimplexNoise from 'https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/+esm';

import { CHUNK_SIZE, CHUNK_HEIGHT, WATER_LEVEL } from './constants.js';

const BEACH_LEVEL = WATER_LEVEL + 2;

const BIOME_TYPES = {
    PLAINS: 0,
    FOREST: 1,
    DENSE_FOREST: 2,
    ROCKY: 3,
    BARREN: 4
};

// Create a seedable random generator
function createPRNG(seed) {
    return function () {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
    };
}

let simplex;
let featureNoise;
let biomeNoise;
let grassDirtNoise;

self.onmessage = function (e) {
    if (e.data.type === 'init') {
        console.log("[Worker] Received init message");
        const seed = e.data.seed;
        // Initialize noise generators with the seed
        simplex = new SimplexNoise({
            random: createPRNG(seed)
        });
        featureNoise = new SimplexNoise({
            random: createPRNG(seed + 1)
        });
        biomeNoise = new SimplexNoise({
            random: createPRNG(seed + 2)
        });
        grassDirtNoise = new SimplexNoise({
            random: createPRNG(seed + 3)
        });
        console.log("[Worker] Noise generators initialized");
        // Notify main thread that initialization is complete
        self.postMessage({ type: 'init_complete' });
    } else {
        const { chunkX, chunkZ } = e.data;
        if (!simplex) {
            console.error("[Worker] Noise generators not initialized!");
            self.postMessage({
                type: 'error',
                message: "Noise generators not initialized",
                chunkX,
                chunkZ
            });
            return;
        }
        try {
            const chunk = generateChunk(chunkX, chunkZ);
            self.postMessage({
                type: 'chunk_data',
                chunkX,
                chunkZ,
                chunkData: chunk.buffer
            }, [chunk.buffer]);
        } catch (error) {
            console.error(`[Worker] Error generating chunk (${chunkX},${chunkZ}):`, error);
            self.postMessage({
                type: 'error',
                message: error.message,
                chunkX,
                chunkZ
            });
        }
    }
};

function getBiomeAt(x, z) {
    const biomeValue = biomeNoise.noise2D(x * 0.005, z * 0.005);
    if (biomeValue < -0.6) return BIOME_TYPES.BARREN;
    if (biomeValue < -0.2) return BIOME_TYPES.ROCKY;
    if (biomeValue < 0.2) return BIOME_TYPES.PLAINS;
    if (biomeValue < 0.6) return BIOME_TYPES.FOREST;
    return BIOME_TYPES.DENSE_FOREST;
}

function generateChunk(chunkX, chunkZ) {
    const chunk = new Int8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT);

    for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let z = 0; z < CHUNK_SIZE; z++) {
            const worldX = chunkX * CHUNK_SIZE + x;
            const worldZ = chunkZ * CHUNK_SIZE + z;

            // Get noise values from initialized generators
            const baseHeight = (simplex.noise2D(worldX * 0.0025, worldZ * 0.0025) + 1) * 0.8;
            const detailHeight = (simplex.noise2D(worldX * 0.01, worldZ * 0.01) + 1) * 0.5;
            const height = Math.floor(0.8 * (baseHeight * 0.8 + detailHeight * 0.2) * (CHUNK_HEIGHT - WATER_LEVEL));

            // Use 3D noise for vertical variations
            const slateNoise = simplex.noise3D(worldX * 0.025, 0, worldZ * 0.025);
            const limestoneNoise = simplex.noise3D(worldX * 0.025, 100, worldZ * 0.025);

            const biome = getBiomeAt(worldX, worldZ);
            const grassDirtValue = grassDirtNoise.noise3D(worldX * 0.1, worldZ * 0.1, biome * 10);

            for (let y = 0; y < CHUNK_HEIGHT; y++) {
                let blockType;

                if (y < height) {
                    if (y < height - 5) {
                        blockType = 3; // Stone
                        if (y < CHUNK_HEIGHT / 2) {
                            if (slateNoise > 0.3 && Math.random() < 0.7) blockType = 8; // Slate
                        } else {
                            if (limestoneNoise > 0.3 && Math.random() < 0.7) blockType = 9; // Limestone
                        }
                    } else if (y < height - 1) {
                        blockType = 2; // Dirt
                    } else {
                        if (y <= BEACH_LEVEL) {
                            blockType = 4; // Sand
                        } else {
                            const grassProbability = biome === BIOME_TYPES.BARREN ? 0.2 : 0.8;
                            blockType = (grassDirtValue < grassProbability) ? 1 : 2;
                        }
                    }
                } else if (y <= WATER_LEVEL) {
                    blockType = 5; // Water
                } else {
                    blockType = 0; // Air
                }

                chunk[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = blockType;
            }
        }
    }

    const chunkFeatures = [];
    for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
            const features = generateChunkFeatures(chunkX + dx, chunkZ + dz);
            features.forEach(feature => {
                // Directly use the feature's world coordinates
                chunkFeatures.push(feature);
            });
        }
    }

    chunkFeatures.forEach(feature => {
        const { worldX, worldZ, type } = feature;
        // Only process features that intersect with this chunk (check if any part is within bounds)
        const minX = worldX - 16; // Assuming max feature radius of 16
        const maxX = worldX + 16;
        const minZ = worldZ - 16;
        const maxZ = worldZ + 16;
        const chunkWorldMinX = chunkX * CHUNK_SIZE;
        const chunkWorldMaxX = (chunkX + 1) * CHUNK_SIZE;
        const chunkWorldMinZ = chunkZ * CHUNK_SIZE;
        const chunkWorldMaxZ = (chunkZ + 1) * CHUNK_SIZE;

        if (maxX >= chunkWorldMinX && minX < chunkWorldMaxX && maxZ >= chunkWorldMinZ && minZ < chunkWorldMaxZ) {
            const baseHeight = getHeightAtWorld(worldX, worldZ);
            if (baseHeight > WATER_LEVEL && baseHeight < CHUNK_HEIGHT - 1) {
                switch (type) {
                    case 'largeTree':
                        generateLargeTree(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight);
                        break;
                    case 'smallTree':
                        generateSmallTree(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight);
                        break;
                    case 'largeRock':
                        generateLargeRockFormation(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight);
                        break;
                    case 'bush':
                        generateBush(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight);
                        break;
                }
            }
        }
    });


    return chunk;
}

function generateChunkFeatures(chunkX, chunkZ) {
    const features = [];
    const worldStartX = chunkX * CHUNK_SIZE;
    const worldStartZ = chunkZ * CHUNK_SIZE;

    // Iterate over the chunk in steps of 3 to reduce density
    for (let x = 0; x < CHUNK_SIZE; x += 3) {
        for (let z = 0; z < CHUNK_SIZE; z += 3) {
            const worldX = worldStartX + x;
            const worldZ = worldStartZ + z;

            // Get the biome at this world position
            const biome = getBiomeAt(worldX, worldZ);

            // Determine the feature type based on biome and noise
            const featureValue = featureNoise.noise2D(worldX * 0.05, worldZ * 0.05);
            let featureType = null;

            switch (biome) {
                case BIOME_TYPES.DENSE_FOREST:
                    if (featureValue > 0.3) featureType = 'smallTree';
                    else if (featureValue > -0.3) featureType = 'bush';
                    break;
                case BIOME_TYPES.FOREST:
                    if (featureValue > 0.8) featureType = 'largeTree';
                    else if (featureValue > 0.6) featureType = 'smallTree';
                    else if (featureValue > -0.2) featureType = 'bush';
                    break;
                case BIOME_TYPES.PLAINS:
                    if (featureValue > 0.8) featureType = 'largeTree';
                    else if (featureValue > 0.5) featureType = 'bush';
                    break;
                case BIOME_TYPES.ROCKY:
                    if (featureValue > 0.7) featureType = 'largeRock';
                    break;
                case BIOME_TYPES.BARREN:
                    if (featureValue > 0.9) featureType = 'largeRock';
                    break;
            }

            // If a feature type was determined, add it to the features array
            if (featureType) {
                features.push({
                    type: featureType,
                    worldX: worldX, // Store world coordinates
                    worldZ: worldZ,
                });
            }
        }
    }

    return features;
}

const TREE_SCALE = 1; // Adjust this value to scale tree size

function generateLargeTree(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight, scale = 1.5) {
    // Calculate scaled tree dimensions
    const unscaledHeight = Math.floor(Math.random() * 10) + 15;
    const treeHeight = Math.max(1, Math.floor(unscaledHeight * scale));
    const trunkHeight = Math.floor(treeHeight * 0.7);
    const leafRadius = Math.floor(treeHeight * 0.4) + Math.floor(2 * scale);

    // Precompute chunk boundaries
    const chunkStartX = chunkX * CHUNK_SIZE;
    const chunkEndX = chunkStartX + CHUNK_SIZE - 1;
    const chunkStartZ = chunkZ * CHUNK_SIZE;
    const chunkEndZ = chunkStartZ + CHUNK_SIZE - 1;

    // Early exit if trunk base is blocked
    const localX = worldX - chunkStartX;
    const localZ = worldZ - chunkStartZ;
    if (localX >= 0 && localX < CHUNK_SIZE && localZ >= 0 && localZ < CHUNK_SIZE) {
        if (getBlockInChunk(chunk, localX, baseHeight, localZ) === 6) return;
    }

    // Optimized leaves generation
    const leavesStartY = baseHeight + Math.max(0, trunkHeight - Math.floor(5 * scale));
    const leavesEndY = baseHeight + treeHeight;
    for (let y = leavesStartY; y <= leavesEndY; y++) {
        const radius = leafRadius - Math.floor((y - leavesStartY) / 3);
        if (radius <= 0) continue;

        const radiusSq = radius * radius;
        const dxMin = Math.max(-radius, chunkStartX - worldX);
        const dxMax = Math.min(radius, chunkEndX - worldX);
        
        for (let dx = dxMin; dx <= dxMax; dx++) {
            const xSq = dx * dx;
            if (xSq > radiusSq) continue;

            const zMax = Math.sqrt(radiusSq - xSq);
            const dzMin = Math.max(-Math.floor(zMax), chunkStartZ - worldZ);
            const dzMax = Math.min(Math.floor(zMax), chunkEndZ - worldZ);
            
            for (let dz = dzMin; dz <= dzMax; dz++) {
                if (xSq + dz * dz > radiusSq) continue;
                setBlockIfInChunk(
                    chunk, chunkX, chunkZ,
                    worldX + dx, worldZ + dz, y,
                    7, 0.08 // 8% leaves
                );
            }
        }
    }

    // Optimized trunk generation with bending
    const bendDirection = Math.random() * Math.PI * 2;
    const cosBend = Math.cos(bendDirection);
    const sinBend = Math.sin(bendDirection);
    const baseRadius = 1.3 * scale;
    const topRadius = 1.0 * scale;
    const bendAmount = 2.5 * scale;

    for (let yRel = 0; yRel < trunkHeight; yRel++) {
        const worldY = baseHeight + yRel;
        if (worldY >= CHUNK_HEIGHT) break;

        const progress = yRel / trunkHeight;
        const currentRadius = baseRadius * (1 - progress) + topRadius * progress;
        const currentRadiusSq = currentRadius * currentRadius;
        const maxD = Math.floor(currentRadius);
        const bendProgress = Math.sin(progress * Math.PI);

        const trunkX = worldX + bendAmount * bendProgress * cosBend;
        const trunkZ = worldZ + bendAmount * bendProgress * sinBend;

        // Calculate dx bounds for current chunk
        const dxMin = Math.max(-maxD, Math.ceil(chunkStartX - 0.5 - trunkX));
        const dxMax = Math.min(maxD, Math.floor(chunkEndX + 0.5 - trunkX - 1e-9));
        if (dxMin > dxMax) continue;

        for (let dx = dxMin; dx <= dxMax; dx++) {
            const xSq = dx * dx;
            if (xSq > currentRadiusSq) continue;

            const zMax = Math.sqrt(currentRadiusSq - xSq);
            const dzMin = Math.max(-Math.floor(zMax), Math.ceil(chunkStartZ - 0.5 - trunkZ));
            const dzMax = Math.min(Math.floor(zMax), Math.floor(chunkEndZ + 0.5 - trunkZ - 1e-9));
            if (dzMin > dzMax) continue;

            for (let dz = dzMin; dz <= dzMax; dz++) {
                if (xSq + dz * dz > currentRadiusSq) continue;
                setBlockIfInChunk(
                    chunk, chunkX, chunkZ,
                    Math.round(trunkX + dx),
                    Math.round(trunkZ + dz),
                    worldY, 6
                );
            }
        }
    }
}

function generateBush(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight) {
    const bushSize = Math.floor(Math.random() * 2) + 2;

    for (let y = baseHeight; y < baseHeight + bushSize && y < CHUNK_HEIGHT; y++) {
        for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
                if (Math.random() < 0.2) {
                    setBlockIfInChunk(
                        chunk,
                        chunkX,
                        chunkZ,
                        worldX + dx,
                        worldZ + dz,
                        y,
                        7 // Leaves
                    );
                }
            }
        }
    }
}

function generateLargeRockFormation(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight) {
    const rockHeight = Math.floor(Math.random() * 4) + 2;
    const rockRadius = Math.floor(rockHeight * 0.7) + 1;
    const rockType = Math.random() < 0.5 ? 3 : 8; // Stone or Slate

    for (let y = baseHeight; y < baseHeight + rockHeight && y < CHUNK_HEIGHT; y++) {
        const layerRadius = Math.max(1, rockRadius - Math.floor((y - baseHeight) / 2));
        for (let dx = -layerRadius; dx <= layerRadius; dx++) {
            for (let dz = -layerRadius; dz <= layerRadius; dz++) {
                if (dx * dx + dz * dz <= layerRadius * layerRadius * (0.7 + Math.random() * 0.3)) {
                    setBlockIfInChunk(
                        chunk,
                        chunkX,
                        chunkZ,
                        worldX + dx,
                        worldZ + dz,
                        y - 1,
                        rockType
                    );
                }
            }
        }
    }
}

function generateSmallTree(chunk, chunkX, chunkZ, worldX, worldZ, baseHeight) {
    const treeHeight = Math.floor(Math.random() * 5) + 5;
    const trunkHeight = Math.floor(treeHeight * 0.6);
    const leafRadius = Math.floor(treeHeight * 0.5) + 1;

    // Check if there's already a tree at this location in the current chunk
    const localX = worldX - chunkX * CHUNK_SIZE;
    const localZ = worldZ - chunkZ * CHUNK_SIZE;
    if (localX >= 0 && localX < CHUNK_SIZE && localZ >= 0 && localZ < CHUNK_SIZE) {
        if (getBlockInChunk(chunk, localX, baseHeight, localZ) === 6) return;
    }

    // Generate trunk
    for (let y = baseHeight; y < baseHeight + trunkHeight && y < CHUNK_HEIGHT; y++) {
        setBlockIfInChunk(chunk, chunkX, chunkZ, worldX, worldZ, y, 6); // Wood
    }

    // Generate leaves
    for (let y = baseHeight + trunkHeight; y <= baseHeight + treeHeight && y < CHUNK_HEIGHT; y++) {
        const layerRadius = leafRadius - Math.floor((y - (baseHeight + trunkHeight - 2)) / 3);
        for (let dx = -layerRadius; dx <= layerRadius; dx++) {
            for (let dz = -layerRadius; dz <= layerRadius; dz++) {
                if (dx * dx + dz * dz <= layerRadius * layerRadius * (0.8 + Math.random() * 0.2)) {
                    setBlockIfInChunk(
                        chunk,
                        chunkX,
                        chunkZ,
                        worldX + dx,
                        worldZ + dz,
                        y,
                        7, // Leaves
                        0.2 // 70% density
                    );
                }
            }
        }
    }
}

function getBlockInChunk(chunk, x, y, z) {
    if (x >= 0 && x < CHUNK_SIZE && z >= 0 && z < CHUNK_SIZE && y >= 0 && y < CHUNK_HEIGHT) {
        return chunk[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
    }
    return 0; // Return air for out-of-bounds blocks
}

function getHeightAtWorld(worldX, worldZ) {
    const baseHeight = (simplex.noise2D(worldX * 0.0025, worldZ * 0.0025) + 1) * 0.8;
    const detailHeight = (simplex.noise2D(worldX * 0.01, worldZ * 0.01) + 1) * 0.5;
    return Math.floor(0.8 * (baseHeight * 0.8 + detailHeight * 0.2) * (CHUNK_HEIGHT - WATER_LEVEL));
}

function setBlockIfInChunk(chunk, chunkX, chunkZ, worldX, worldZ, y, type, density = 1.0) {
    if (y < 0 || y >= CHUNK_HEIGHT) return;
    if (Math.random() > density) return;

    const localX = worldX - chunkX * CHUNK_SIZE;
    const localZ = worldZ - chunkZ * CHUNK_SIZE;

    if (localX >= 0 && localX < CHUNK_SIZE && localZ >= 0 && localZ < CHUNK_SIZE) {
        chunk[localX + localZ * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = type;
    }
}

export {
    generateChunk,
}

================================================================================
File: ./scripts/geometryWorker.js
================================================================================

import { CHUNK_SIZE, CHUNK_HEIGHT } from './constants.js';

let materials = {};
let seed = 0;
let colorPRNG = null;

function fastVariation(x, y, z) {
    // Use more iterations of bit mixing to get better distribution
    let seed = x * 3191 ^ y * 1337 ^ z * 7919;

    // Additional mixing steps
    seed ^= seed << 13;
    seed ^= seed >> 17;
    seed ^= seed << 5;
    seed ^= seed >> 7;
    seed ^= seed << 11;

    // Map the result to the range [-1, 1]
    return ((seed & 0x3fffffff) / 0x3fffffff) * 2 - 1;
}

function getBlockVariation(worldX, y, worldZ, blockType) {
    const config = VARIATION_CONFIG[blockType] || {};
    if (!config.scale) return [1, 1, 1];

    // Get unique variation per channel
    const variations = [
        fastVariation(
            Math.floor(worldX / config.scale),
            Math.floor(y / config.scale),
            Math.floor(worldZ / config.scale)
        ),
        fastVariation(
            Math.floor(worldX / config.scale) + 7919,
            Math.floor(y / config.scale),
            Math.floor(worldZ / config.scale)
        ),
        fastVariation(
            Math.floor(worldX / config.scale),
            Math.floor(y / config.scale) + 3191,
            Math.floor(worldZ / config.scale)
        )
    ];

    return variations.map((v, i) =>
        1 + (v - 0.5) * config.intensity * (config.channelBias?.[i] || 1)
    );
}

const VARIATION_CONFIG = {
    1: { // Grass
        scale: .2,     // Increase scale for more gradual changes
        intensity: 0.06,
        channelBias: [0.9, 1.1, 0.9]
    },
    2: { // Dirt
        scale: .4,
        intensity: 0.15,
        channelBias: [1.0, 0.95, 0.9]
    },
    3: { // Stone
        scale: .3,
        intensity: 0.1,
        channelBias: [1.0, 1.0, 1.0]
    },
    4: { // Sand
        scale: 1,
        intensity: 0.05,
        channelBias: [1.1, 1.05, 0.95]
    },
    6: { // Wood
        scale: 2.0,
        intensity: 0.15,
        channelBias: [0.95, 0.9, 0.85]
    },
    7: { // Leaves
        scale: .1,
        intensity: 0.2,
        channelBias: [0.8, 1.2, 0.7]
    },
    8: { // Slate
        scale: .3,
        intensity: 0.15,
        channelBias: [0.9, 0.95, 1.1]
    },
    9: { // Limestone
        scale: .4,
        intensity: 0.12,
        channelBias: [1.0, 1.0, 1.0]
    }
};

function createPRNG(seed) {
    return function () {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
    };
}

self.onmessage = function (e) {
    switch (e.data.type) {
        case 'init':
            materials = e.data.materials;
            seed = e.data.seed;
            colorPRNG = createPRNG(seed);
            break;

        case 'process_chunk':
            const start = performance.now();
            const { chunkX, chunkZ, chunkData, adjacentChunks } = e.data;
            const result = generateGeometry(
                chunkX,
                chunkZ,
                new Int8Array(chunkData),
                adjacentChunks
            );
            const duration = performance.now() - start;

            self.postMessage({
                type: 'geometry_data',
                duration,
                ...result
            }, [
                result.solid.positions.buffer,
                result.solid.normals.buffer,
                result.solid.colors.buffer,
                result.solid.indices.buffer,
                result.water.positions.buffer,
                result.water.normals.buffer,
                result.water.indices.buffer
            ]);
            break;
    }
};


function generateGeometry(chunkX, chunkZ, chunkData, adjacentChunks) {
    const solid = { positions: [], normals: [], colors: [], indices: [] };
    const water = { positions: [], normals: [], indices: [] };
    const leaves = { positions: [], offsets: [], colors: [], indices: [] };

    // Moved addFace inside generateGeometry and added AO calculations
    const addFace = (isWater, normal, localX, localY, localZ, color, isLeaf = false) => {
        const target = isWater ? water : solid;

        // Vertex positions in world coordinates
        let positions = [];
        let aoValues = [];

        // Define face vertices based on normal
        if (normal[0] === 1) { // East
            positions.push(
                [localX + 1, localY, localZ],
                [localX + 1, localY + 1, localZ],
                [localX + 1, localY + 1, localZ + 1],
                [localX + 1, localY, localZ + 1]
            );
        } else if (normal[0] === -1) { // West
            positions.push(
                [localX, localY, localZ + 1],
                [localX, localY + 1, localZ + 1],
                [localX, localY + 1, localZ],
                [localX, localY, localZ]
            );
        } else if (normal[1] === 1) { // Top
            positions.push(
                [localX, localY + 1, localZ],
                [localX, localY + 1, localZ + 1],
                [localX + 1, localY + 1, localZ + 1],
                [localX + 1, localY + 1, localZ]
            );
        } else if (normal[1] === -1) { // Bottom
            positions.push(
                [localX, localY, localZ],
                [localX + 1, localY, localZ],
                [localX + 1, localY, localZ + 1],
                [localX, localY, localZ + 1]
            );
        } else if (normal[2] === 1) { // North
            positions.push(
                [localX + 1, localY, localZ + 1],
                [localX + 1, localY + 1, localZ + 1],
                [localX, localY + 1, localZ + 1],
                [localX, localY, localZ + 1]
            );
        } else { // South
            positions.push(
                [localX, localY, localZ],
                [localX, localY + 1, localZ],
                [localX + 1, localY + 1, localZ],
                [localX + 1, localY, localZ]
            );
        }

        // Calculate ambient occlusion for each vertex
        positions.forEach(pos => {
            const [x, y, z] = pos;
            let ao = 0;

            // Check 3 adjacent blocks for occlusion
            const checks = [];
            if (normal[1] === 0) { // Vertical faces
                checks.push(
                    [x - normal[0], y, z - normal[2]],
                    [x - normal[0], y - 1, z - normal[2]],
                    [x, y - 1, z]
                );
            } else { // Horizontal faces
                checks.push(
                    [x - 1, y, z],
                    [x, y, z - 1],
                    [x - 1, y, z - 1]
                );
            }

            checks.forEach(check => {
                const [cx, cy, cz] = check;
                if (getBlockInWorld(
                    chunkX, chunkZ,
                    Math.floor(cx),
                    Math.floor(cy),
                    Math.floor(cz),
                    chunkData,
                    adjacentChunks
                ) !== 0) {
                    ao += 0.3;
                }
            });

            aoValues.push(Math.min(1, ao));
        });

        // Add vertices with AO-adjusted colors
        positions.forEach((pos, i) => {
            target.positions.push(...pos);
            target.normals.push(...normal);

            if (!isWater) {
                const ao = aoValues[i];
                const darkened = color.map(c => c * (1 - ao * 0.45)); // AO intensity
                target.colors.push(...darkened);
            }
        });

        // Calculate starting vertex index for this face
        const vertexCount = target.positions.length / 3;

        // Add indices
        target.indices.push(
            vertexCount, vertexCount + 1, vertexCount + 2,
            vertexCount, vertexCount + 2, vertexCount + 3
        );
    };

    for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let y = 0; y < CHUNK_HEIGHT; y++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                const blockType = chunkData[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
                if (blockType === 0) continue;

                const neighbors = {
                    px: getBlockInWorld(chunkX, chunkZ, x + 1, y, z, chunkData, adjacentChunks),
                    nx: getBlockInWorld(chunkX, chunkZ, x - 1, y, z, chunkData, adjacentChunks),
                    py: getBlockInWorld(chunkX, chunkZ, x, y + 1, z, chunkData, adjacentChunks),
                    ny: getBlockInWorld(chunkX, chunkZ, x, y - 1, z, chunkData, adjacentChunks),
                    pz: getBlockInWorld(chunkX, chunkZ, x, y, z + 1, chunkData, adjacentChunks),
                    nz: getBlockInWorld(chunkX, chunkZ, x, y, z - 1, chunkData, adjacentChunks)
                };

                // Skip processing completely enclosed solid blocks
                if (x > 0 && x < CHUNK_SIZE - 1 &&
                    z > 0 && z < CHUNK_SIZE - 1 && 
                    y > 0 && y < CHUNK_HEIGHT - 1) {
                    if (!isTransparent(neighbors.px) &&
                        !isTransparent(neighbors.nx) &&
                        !isTransparent(neighbors.py) &&
                        !isTransparent(neighbors.ny) &&
                        !isTransparent(neighbors.pz) &&
                        !isTransparent(neighbors.nz)) {
                        continue;
                    }
                }


                const isWater = blockType === 5;
                const isLeaf = blockType === 7;
                const baseColor = hexToRGB(materials[blockType].color);
                const colorMultipliers = getBlockVariation(
                    chunkX * CHUNK_SIZE + x,
                    y,
                    chunkZ * CHUNK_SIZE + z,
                    blockType
                );
                const finalColor = baseColor.map((c, i) => Math.min(1, Math.max(0, c * colorMultipliers[i])));

                if (isLeaf) {
                    const cx = x + 0.5;
                    const cy = y + 0.5;
                    const cz = z + 0.5;
                    const offsets = [
                        [-0.5, -0.5], [0.5, -0.5],
                        [0.5, 0.5], [-0.5, 0.5]
                    ];
                    const baseIndex = leaves.positions.length / 3;

                    offsets.forEach(([ox, oy]) => {
                        leaves.positions.push(cx, cy, cz);
                        leaves.offsets.push(ox, oy);
                        leaves.colors.push(...finalColor);
                    });

                    leaves.indices.push(
                        baseIndex, baseIndex + 1, baseIndex + 2,
                        baseIndex, baseIndex + 2, baseIndex + 3
                    );
                } else {
                    // Existing face checks for other block types
                    if ((isWater && neighbors.px === 0) || (!isWater && isTransparent(neighbors.px)))
                        addFace(isWater, [1, 0, 0], x, y, z, finalColor);
                    if ((isWater && neighbors.nx === 0) || (!isWater && isTransparent(neighbors.nx)))
                        addFace(isWater, [-1, 0, 0], x, y, z, finalColor);
                    if ((isWater && neighbors.py === 0) || (!isWater && isTransparent(neighbors.py)))
                        addFace(isWater, [0, 1, 0], x, y, z, finalColor);
                    if ((isWater && neighbors.ny === 0) || (!isWater && isTransparent(neighbors.ny)))
                        addFace(isWater, [0, -1, 0], x, y, z, finalColor);
                    if ((isWater && neighbors.pz === 0) || (!isWater && isTransparent(neighbors.pz)))
                        addFace(isWater, [0, 0, 1], x, y, z, finalColor);
                    if ((isWater && neighbors.nz === 0) || (!isWater && isTransparent(neighbors.nz)))
                        addFace(isWater, [0, 0, -1], x, y, z, finalColor);
                }
            }
        }
    }


    return {
        chunkX,
        chunkZ,
        solid: packageGeometry(solid),
        water: packageGeometry(water),
        leaves: packageLeavesGeometry(leaves) || { positions: [], offsets: [], colors: [], indices: [] }
    };
}

function packageLeavesGeometry(leaves) {
    return {
        positions: new Float32Array(leaves.positions),
        offsets: new Float32Array(leaves.offsets),
        colors: new Float32Array(leaves.colors),
        indices: new Uint32Array(leaves.indices)
    };
}

function getBlockInWorld(currentChunkX, currentChunkZ, localX, localY, localZ, currentChunkData, adjacentChunks) {
    if (localY < 0 || localY >= CHUNK_HEIGHT) return 0;

    // Calculate world coordinates
    const worldX = currentChunkX * CHUNK_SIZE + localX;
    const worldZ = currentChunkZ * CHUNK_SIZE + localZ;

    // Calculate target chunk coordinates
    const targetChunkX = Math.floor(worldX / CHUNK_SIZE);
    const targetChunkZ = Math.floor(worldZ / CHUNK_SIZE);

    // Calculate local coordinates within target chunk
    let targetLocalX = worldX % CHUNK_SIZE;
    let targetLocalZ = worldZ % CHUNK_SIZE;
    // Adjust for negative coordinates
    if (targetLocalX < 0) targetLocalX += CHUNK_SIZE;
    if (targetLocalZ < 0) targetLocalZ += CHUNK_SIZE;

    // Check if target is current chunk
    if (targetChunkX === currentChunkX && targetChunkZ === currentChunkZ) {
        return getBlock(currentChunkData, targetLocalX, localY, targetLocalZ);
    }

    // Check adjacent chunks
    const chunkKey = `${targetChunkX},${targetChunkZ}`;
    if (adjacentChunks && adjacentChunks[chunkKey]) {
        const adjChunkData = new Int8Array(adjacentChunks[chunkKey]);
        return getBlock(adjChunkData, targetLocalX, localY, targetLocalZ);
    }

    // Treat unloaded chunks as non-transparent (stone)
    return 3; // Changed from 0 to 3 (stone)
}

// Helper functions
function hexToRGB(hex) {
    return [
        ((hex >> 16) & 255) / 255,
        ((hex >> 8) & 255) / 255,
        (hex & 255) / 255
    ];
}

function packageGeometry(geo) {
    return {
        positions: new Float32Array(geo.positions),
        normals: new Float32Array(geo.normals),
        colors: geo.colors ? new Float32Array(geo.colors) : null,
        indices: new Uint32Array(geo.indices)
    };
}

function getBlock(chunkData, x, y, z) {
    if (x < 0 || x >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE || y < 0 || y >= CHUNK_HEIGHT)
        return 0;
    return chunkData[x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
}

function isTransparent(blockType) {
    return blockType === 0 || blockType === 5 || blockType === 7;
}

export default self;
